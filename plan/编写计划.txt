
-----------------------2019/11/15---------------------------------

!!!事先说明，由于课设限制时间较短，且电脑内存有限
    微服务方面分得不太细化/合理，表结构也是有不合理的地方（如过多实现都依赖到一张表中去）

########################################################################################################################
##
## redis缓存初始化策略
##
########################################################################################################################
java代码中key记得加上存储头，便于可视化工具分离
项目启动前使用独立方法(我这里就写个单元测试，比较方便)初始化一次
    (先不这么干，留下思路)为了更加通用，分数 = 10000 - 从库里查询配送员已接单数目 * 10

初始化添加分数语句： ZADD qid1 1 cid1

取分数最高的快递员id： ZREVRANGE qid1 0 0
模拟数据：ZADD qid1 1 cid1
         ZADD qid1 2 cid2
         ZADD qid1 3 cid3

记录日志语句： lua脚本先 set 订单id 配送员id ，然后call('expire',KEYS[1],ARGV[1])

总结脚本所需参数： 区域id(学校id) 配送员id 订单id 初始分数


########################################################################################################################
##
## 配送员分区问题
##
########################################################################################################################
课设的需求文档是按照从化的两个地方分区
但感觉这样做很不伦不类，放在别人眼里可能根本没有参考意义
即便是自打自闹的小项目也好，还是想更符合实际

所以就按照全国高校的粒度来进行区域划分，即 sys_user 表中的 school_id 来进行划分
分配配送员的时候按照用户的 school_id 匹配同样 school_id 的配送员





########################################################################################################################
##
## 订单派送保证一致性问题
##
########################################################################################################################
lua简单入门相关博客：https://www.jianshu.com/p/a555facfd6c8

用户下单后，发送mq事务消息，利用redis分数权重的结构实现分配配送员
redis中每个配送员初始分数为10000，每成功接到一单就扣10分

代码/业务实现具体就是这样
// 多线程批量发送消息可以很方便的测试效果
消息队列处理函数(String OrderId){
    数据库业务操作函数(orderId);
    // 如果在此处宕机，mysql已提交，mq重投，但由于mysql记录已存在，相当于不执行，直接跳出来
    删除日志;
    // 如果在此处系统宕机，依旧是mysql已提交，mq重投，虽然删除日志的操作重复了，但不影响一致性
    // 如果redis挂了没持久化，也是日志没被删除而已，ttl时间过后自动删除，不会影响正常业务
    // 如果系统和redis都挂了，mysql已提交，mq重投，无论redis有没有持久化，也只是影响到日志而已，跟上一个如果相似，不影响正常业务
}

@事务注解
数据库业务操作函数(String orderId){
    记录 = mysql在配送任务表中查询orderId的纪律
    if(记录不存在){
        String cid = redis/es 根据订单id查日志（日志的key/vlues形式为 订单id=配送员id）
        if(cid不为空){
            分配配送员id为cid的配送员配送此订单
            // 删除日志(废除)
            // 假设在此处删除日志： todo: 假如系统在这里宕机了，配送员90分，那mysql事务回滚，mq回滚，因为日志删除，会进入下面的逻辑，配送员会被多扣分的
            // 假设不在此处删除日志： todo 系统宕机，配送员90分，mysql和mq都回滚，但因为日志依然存在，所以还是进入到此处逻辑，不影响分数一致性
        }else{
            // 使用lua实现确保一致性
            redis取分数最高配送员，并减掉该配送员分数10，记录日志
            mysql配送员配送记录
            // 如果在在之后redis宕机了，代码还是会正常走下去，数据恢复只能靠aof了，默认是每秒保存，不管有没有持久化，都不影响正常业务主线
            // 如果在此处是系统宕机了(redis没死)，那么mysql事务也会回滚，mq也会重新发送，但因为有日志的存在，会进入上面的逻辑
            // 如果系统和redis都死了，而redis持久化了，那么下次mq重投就会进入上面，如果没持久化，就重新进入此处，无论哪种情况，
            //     都保证了分数的一致性（一般不会发生redis宕机，因为redis通常是第三方如阿里提供的远程服务）
        }
    }
}


########################################################################################################################
##
## 订单何时发送消息队列安排配送员配送
##
########################################################################################################################
用户付款后，用户付款前后只要还没分配配送员则订单状态暂时还是<等待接单>




########################################################################################################################
##
## 配送员请假问题
##
########################################################################################################################
配送员如果点击请假，先在缓存集合中删除该配送员，并修改当前配送员的状态为请假状态，并将当前配送员所接的订单全部取消，
然后将取消的订单号重新发送到队列中分发新的配送员，还要把分数加回去

请假的配送员仍然可以登录系统，但系统不会再给该配送员分配配送订单任务，直到配送员点击回到岗位




########################################################################################################################
##
## 订单任务分配给配送员后(<>中的名词可能会改)
##
########################################################################################################################
任务还没分配到配送员时，显示<等待接单>
上门收件：
    配送员接受到任务时，配送状态为<等待揽收>

    配送员成功收件时，配送状态为<正在配送>
    配送员收件失败时，配送状态显示为<收件失败>及原因

    配送员成功配送完成时，配送状态为<配送完成>
    配送员配送失败时，选择是否重新投递
        若选择重新投递，配送状态为<正在配送>
        若选择不再投递，配送状态为<取消配送>及原因，加回分数，工作量+1

送件上门：
    配送员接受到任务时，配送状态为<等待揽收>

    配送员接受到任务时，配送状态为<正在配送>

    配送员配送成功后，配送状态为<配送完成>，加回分数，工作量+1
    配送员配送失败时，选择是否重新投递
        若选择重新投递，配送状态为<正在配送>
        若选择不再投递，配送状态为<取消配送/派送失败>及原因，加回分数，工作量+1



########################################################################################################################
##
## 记账子系统(配送员工资)
##
########################################################################################################################
快递员计件：根据 order_info 表的 order_status(完成状态) 和 update_time 统计配送员某段时间内的配送量
